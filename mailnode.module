<?php
// $Id$

###############################################################################
###   This module allows users to email a Drupal installation running the
###   Exim email server to create discussions and respond to comments.
###   Because it is tied directly to Exim, emails are processed immediately
###   upon receipt in the mail server.  Mails should be sent to purl_group_name@server.com
###   rather than to a single email address.
###
###   Written by Conan Albrecht   March 2009
###   Thanks to the mail2web module for the inspiration for some of this.
###

require_once("phpmailer/class.phpmailer.php");
require_once("mailnode_phpmailer.inc");
require_once('mailnode_api.inc');

/** Implementation of hook_menu(). */
function mailnode_menu() {
  # Administration
  $items['admin/messaging/mailnode'] = array(
    'title' => 'MailNode',
    'description' => t('Configure discussions/comments generated from email'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mailnode_admin_settings'),
    'access arguments' => array('administer notifications'),
  );
  $items['mailnode/subscriptions'] = array(
    'title' => t('Manage Group Subscriptions'),
    'description' => t('Allows users to manage their space subscriptions'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mailnode_subscriptions_settings_form'),
    'access arguments' => array('create blog entries'), // This is a hack to 
    // restrict access to authenticated users as can't restrict menu items by role AFAIK.
    // TODO right thing to do actually is define new permission for this module... Silly me.
  );
  $items['mailnode/unsubscribe/%node'] = array(
    'title' => t('Unsubscribe from discussion'),
    'description' => t('Users who hit this page will not get more emails for
                       comments on the node.'),
    'page callback' => 'mailnode_unsubscribe_thread',
    'page arguments' => array(2),
    'access arguments' => array('create blog entries'), // This is a hack to 
    // restrict access to authenticated users as can't restrict menu items by role AFAIK.
  );
  $items['mailnode/subscribe/%node'] = array(
    'title' => t('Subscribe to discussion'),
    'description' => t('Users who hit this page will not get more emails for
                       comments on the node.'),
    'page callback' => 'mailnode_subscribe_thread',
    'page arguments' => array(2),
    'access arguments' => array('create blog entries'), // This is a hack to 
    // restrict access to authenticated users as can't restrict menu items by role AFAIK.
  );
  // TODO when someone not in a group comments on a post -- send them an email asking if they want to join -- let them reply w/ a "yes" the body.
  // Also anonymous commenters could be asked to sign up first before allowing them to comment -- or at least let group admins add people easily add people to group a la Open Atrium
  return $items;
}

/*
 * Implementation of hook_init().
 */
function mailnode_init() {
  drupal_add_css(drupal_get_path('module', 'mailnode') . "/mailnode.css");
}

/** Implementation of hook_help */
function mailnode_help($path, $arg) {
  switch ($path) {
    case 'admin/messaging/mailnode':
      return '<p>' . t("Mailnode allows users to start new discussions by email and post comments on existing discussions
       by simply replying to emails.  It plugs directly into the Exim mail server, which allows it to process emails
       immediately upon receipt in the system.  It assumes you are using the Organic Groups module for groups and
       the Notifications Framework for site email.  It also assume your installed mail server is Exim 4. 
       Instructions are as follows:
       <ul>
         <li>To start a discussion, a group member should send email to groupname@yourserver.com.
         <li>To post a comment on an existing discussion, a group member should simply reply to the autogenerated
             email he or she receives.
       </ul> 
       Important notes:
       <ul>
         <li>You must customize the DRUPAL_DIR variable in mailnode_exim4_bootstramp_command_line.php file to point at your
             Drupal installation.  
         <li>You must install the router and transport into your Exim4 configuration files.  See the documentation for information
             about setting this up and testing it.
         <li>In Notifications General Settings, you can check 'Notify poster of own posts' so original posters get return
             emails when they post via email.
         <li>This module essentially allows group members to post to your site directly from their email box -- it bypasses
             their login name and password and simply matches the email address.  This can be spoofed by anyone smart enough 
             to do it.  The module has some security in place, but by its very nature, it is a potential security risk.  Use
             this module only on sites where this is acceptable.
       </ul>");
  }
}

/** Admin settings form */
function mailnode_admin_settings() {
  $form['mailnode_server_string'] = array(
    '#title' => t('Server string for Message Id'),
    '#type' => 'textfield',
    '#default_value' => variable_get('mailnode_server_string', 'example.com'),
    '#description' => t('Server name to be used in message id\'s to be included in outgoing emails (your domain name, like example.com).'),
  );
  $form['mailnode_reply_text'] = array(
    '#title' => t('Reply Separator Text'),
    '#type' => 'textfield',
    '#default_value' => variable_get('mailnode_reply_text', t("=- Reply above this line -=")),
    '#description' => t('The text to separate where the user should reply above.'),
  );
  $form['mailnode_noreply_email'] = array(
    '#title' => t('No-Reply Email Address'),
    '#type' => 'textfield',
    '#default_value' => variable_get("mailnode_noreply_email", t("no-reply@" . variable_get("mailnode_server_string", "example.com"))),
    '#description' => t('The email address for to use for mails that should not be replied to.'),
  );
  $form['mailnode_max_message_size'] = array(
    '#title' => t('Maximum message size (in Kb)'),
    '#type' => 'textfield',
    '#default_value' => variable_get('mailnode_max_message_size', '100'),
    '#description' => t('Any messages over this size will be rejected.  Set to 0 for unlimited.'),
  );
  $form['mailnode_max_posts_per_hour'] = array(
    '#title' => t('Maximum posts per hour'),
    '#type' => 'textfield',
    '#default_value' => variable_get('mailnode_max_posts_per_hour', '20'),
    '#description' => t('The maximum number of messages a user is able to post per hour by email.  Set to 0 for unlimited.'),
  );
  $form['mailnode_cleaner'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable message cleaner'),
    '#description' => t('Attempt to remove email client gunk at bottom of emails, like "On Jan 26, 2009, John Doe wrote:".
      If parts of emails are getting stripped out or appearing empty, turn this off.'),
    '#default_value' => variable_get('mailnode_cleaner', 0),
  );
  return system_settings_form($form);
}

function mailnode_subscriptions_settings_form() {
  global $user;
  
  $sql = 'SELECT m.sid as gid, m.subscription_type, n.title
          FROM {mailnode_subscription} m, {node} n
          WHERE m.sid = n.nid
          AND m.uid = %d
          AND m.space_type = "og"
          ORDER BY n.title';
  
  $results = db_query($sql, $user->uid);
  
  $subscription_options = array(
    'email' => t('Email'),
    'no email' => t('No email'),
    'digest email' => t('Digest email'),
  );
  
  $form = array();
  
  while ($data = db_fetch_array($results)) {
    $form['mailnode_og'][$data['gid']] = array(
      '#type' => 'select',
      '#title' => l(t($data['title']), "node/" . $data['gid']),
      '#default_value' => $data['subscription_type'],
      '#options' => $subscription_options,
    );
  }
  
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Save')
    );
  
  return $form;
}

function mailnode_subscriptions_settings_form_submit($form, &$form_state) {
  global $user;
  foreach ($form_state['values'] as $gid => $sub_type) {
    // We only care about GIDs and their values.
    if (is_numeric($gid)) {
      db_query("UPDATE {mailnode_subscription}
               SET subscription_type = '%s'
               WHERE uid = %d
               AND sid = %d
               AND space_type = 'og'", $sub_type, $user->uid, $gid);
      
      if ($sub_type != "email") {
        mailnode_delete_group_threads($gid, $user->uid);
      }
    }
  }
  drupal_set_message("Group subscriptions updated.");
}

function mailnode_unsubscribe_thread($node) {
  global $user;
  $success = mailnode_delete_thread_subscription($node->nid, $user->uid);
  
  if ($success) {
    return "<div class='messages success'>You were successfully unsubscribed from
    the discussion <em>" . l($node->title, "node/" . $node->nid) . " </em>&nbsp;&nbsp; 
     " . l("Undo", "mailnode/subscribe/" . $node->nid, array("attributes" => array("id" => "mailnode_undo")))
           . "</div>"; //Plus subscribe people to thread when they make a comment.
  }
}

function mailnode_subscribe_thread($node) {
  global $user;
  mailnode_save_thread_subscriptions($node->nid, array($user->uid));
  
  return "<div class='messages success'>You were successfully subscribed to
    the discussion <em>" . l($node->title, "node/" . $node->nid) . " </em>&nbsp;&nbsp; 
     " . l("Undo", "mailnode/unsubscribe/" . $node->nid, array("attributes" => array("id" => "mailnode_undo")))
           . "</div>"; //TODO add undo which resubscribes people. Plus handle errors. Plus subscribe people to thread when they make a comment. When someone shifts to digest or no email, delete all thread subscriptions.
}

/** hook_message_alter - allows us to alter email messages sent from the site */

function mailnode_message_alter(&$message, $info) {
  $info_str_org = var_export($info, TRUE);
  # For now, just for non digested emails
  $params = Array();
  $account = $message->account;
  $posterid = -1;
  if (!empty($message->notifications) && empty($message->notifications['digest']) && $info['group'] == 'mail') {
    $event = current($message->notifications['events']);
    if ($event->type == 'node' && !empty($event->objects['node'])) {
      $params['uid'] = $account->uid;
      $params['nid'] = $event->objects['node']->nid;
      $posterid = $event->objects['node']->uid;
      if ($event->action == 'comment' && !empty($event->objects['comment'])) {
        $params['cid'] = $event->objects['comment']->cid;
        $posterid = $event->objects['comment']->uid;
      }
    } 
  }
  # If we've got some params out of the message, embed them into the message id for emails only
  # and only if the recipient of the message is allowed to post comments.
  $reply = $account->mail;
  if (empty($reply)) {
    $reply = variable_get("mailnode_noreply_email", t("no-reply@" . variable_get("mailnode_server_string", "example.com")));
  }
  $groups = array_values($event->objects['node']->og_groups_both);
  if (!empty($groups)) {
    $groupname = strtolower(str_replace(' ', '-', $groups[0]));
  }
  if ($groupname && $params && user_access('post comments', $account)) {
    $poster = user_load($posterid);
    $fullpostername = blueprint_username($poster, true);
    
    $message->params['mail']['headers']['To'] = "\"" . $groupname . "\"" . " <" . $groupname . '@island.byu.edu'  . ">"; 
    
    # FROM
    $message->params['mail']['headers']['From'] = $fullpostername . ' <' . $groupname . '@island.byu.edu' . '>';
    //$message->params['mail']['headers']['From'] = $fullpostername . ' <' . $poster->mail . '>'; // this doesn't work
    // messages directed at person writing post (i.e. from = to) don't thread correctly. Need to add person as to but not
    // actually send it to them.
    
    # Reply-To
    //$message->params['mail']['headers']['Reply-To'] = $groupname . '@island.byu.edu';
    //$message->params['mail']['headers']['x-s'] = $fullpostername . ' <' . $poster->mail . '>';
    if ($account->mail != $poster->mail) {
      //$message->params['mail']['headers']['Bcc'] = $fullpostername . ' <' . $poster->mail . '>'; 
    }
       
    $message->params['mail']['headers']['Reply-To'] = $fullpostername . ' <' . $poster->mail . '>'; 

    $message->params['mail']['headers']['Message-ID'] = mailnode_build_messageid($params);
    $message->params['mail']['headers']['List-Id'] = '<' . $groupname . '@island.byu.edu' . '>';
    $message->params['mail']['headers']['List-Post'] = '<' . 'mailto:' . $groupname . '@island.byu.edu' . '>';
    $message->params['mail']['headers']['List-Archive'] = 'https://island.byu.edu/group/' . $groupname;
    # get the text of the message so we can modify it/list
    # Add reply separator for the reply
    $separator = variable_get('mailnode_reply_text', t("=- Reply above this line -=\n"));
    $prefix = array($separator);
    if (!empty($message->body['#prefix'])) {
      $prefix[] = $message->body['#prefix'];
    }
    # add the "user wrote:" part
   // $fullpostername = blueprint_username($poster, false);
//    if ($fullpostername) {
//#      $prefix[] = $fullpostername . ' (' . $poster->mail . ') wrote:<br />';
//      $prefix[] = '<br />' . $fullpostername . ' wrote:<br />';
//    }elseif ($poster) {
//#      $prefix[] = $poster->name . ' (' . $poster->mail . ') wrote:<br />';
//      $prefix[] = $poster->name . ' wrote:<br />';
//    }
    # This glue text is a best guess, may cause trouble though, also with filtering (?).
    # So we better explicitly set glue text for all sending methods
    $info += array('glue' => "<br />");
    $message->body['#prefix'] = implode($info['glue'], $prefix);
    #  This is a simple solution to mail clients that strip out the messageid and/or in-reply-to headers.
    #  We insert the messageid in the footer to use as a back-up to the header info
    #  see http:#drupal.org/node/290214
    $message->body['#footer'] .= t('<br />MessageID=' . $message->params['mail']['headers']['Message-ID']);
  }
}


/** Parse a comment from a reply mail */
function mailnode_parse_messagebody($mailbody) {
  $separator = variable_get('mailnode_reply_text', t("=- Reply above this line -="));
  $pos = strpos($mailbody, $separator);
  if ($pos > 0) {
    return substr($mailbody, 0, $pos);
  }
  return "";
}


/** Parse out email extras, like a standard signature, a reply addition, etc. */
function mailnode_clean_email($email) {
  $mailbody = $email['mailbody'];
  
  //file_save_data(var_export($mailbody, true), '/tmp/messaging_object.txt', FILE_EXISTS_RENAME);
  # strip off anything below the email signature, assuming the user has a standard signature separator
  $search = preg_match_all("/^-- [\n\r]*$/m", $mailbody, $matches, PREG_OFFSET_CAPTURE);
  if (!empty($matches[0])) {
    $temp = end($matches[0]);
    $mailbody = substr($mailbody, 0, $temp[1]); # parse last one off, since that is probably the signature
  }
  # Remove Gmail cruft-- remove the reply start text (On this date, so and so said...)
  $gmail_search = preg_match("/On\s[a-zA-Z]{3},\s[a-zA-Z]{3}\s[0-9]{1,2},\s[0-9]{4}\sat\s[0-9]{1,2}:[0-9]{2}\s[PM|AM]/s",
                             $mailbody, $gmail_matches, PREG_OFFSET_CAPTURE);
  if (!empty($gmail_matches[0])) {
    $mailbody = substr($mailbody, 0, $gmail_matches[0][1]);
  }
  
  # Remove Outlook cruft.
  $outlook_search = preg_match("/-{4,7}Original.Message-{4,7}.From:\s[a-zA-Z\s.\-@\[\]_123:]{0,100}(Sender|Sent):\s/s",
                       $mailbody, $outlook_matches, PREG_OFFSET_CAPTURE);
  if (!empty($outlook_matches[0])) {
    $mailbody = substr($mailbody, 0, $outlook_matches[0][1]);
  }
  
  # Remove unknown email client #1 cruft.
  # Sample text = From: Matthew Ehle information-systems@island.byu.edu [1] To: nrodgers@byu.net [2] Sent: Monday, August 17, 2009 1:18:59 PM Subject: [Information Systems] Java Programmer
  $client1_search = preg_match("/From:.[a-zA-Z]{3,}.[a-zA-Z]{3,}\s[a-zA-Z0-9._-]+@[a-zA-Z0-9-]+\.[a-zA-Z.]{2,5}.*To:.*@.*Sent:.*,.*Subject:/s",
                       $mailbody, $client1_matches, PREG_OFFSET_CAPTURE);
  if (!empty($client1_matches[0])) {
    $mailbody = substr($mailbody, 0, $client1_matches[0][1]);
  }
  
  # Remove unknown email cilent #2 cruft.
  # Sample text = On Aug 13, 2009, at 12:36 PM, Jonathan B Criddle wrote:
  $client2_search = preg_match("/On\s[a-zA-Z]{3}\s[0-9]{1,2},\s[0-9]{4},\sat\s[0-9:]{4,5}.[AMP]{2},/",
                       $mailbody, $client2_matches, PREG_OFFSET_CAPTURE);
  if (!empty($client2_matches[0])) {
    $mailbody = substr($mailbody, 0, $client2_matches[0][1]);
  }
  
  # Remove unknown email cilent #3 cruft.
  /* Sample text:
    > To: jwfergie@hotmail.com
  > Subject: Re: [Information Systems] Win7 a win
  > From: information-systems@island.byu.edu
  > Date: Fri, 21 Aug 2009 13:48:47 -0600
  > 
  > */
  $client3_search = preg_match("/>.To:.[a-zA-Z0-9._-]+@[a-zA-Z0-9-]+\.[a-zA-Z.]{2,5}[>\s]{2,}Subject:.Re:.\[[a-zA-Z\s]{3,}\].[a-zA-Z0-9\s>]{3,}From:.[a-zA-Z0-9._-]+@[a-zA-Z0-9-]+\.[a-zA-Z.]{2,5}/s",
                       $mailbody, $client3_matches, PREG_OFFSET_CAPTURE);
  if (!empty($client3_matches[0])) {
    $mailbody = substr($mailbody, 0, $client3_matches[0][1]);
  }

  # convert all line endings to unix-style
  $mailbody = str_replace("\r\n", "\n", $mailbody);
  $mailbody = str_replace("\r", "\n", $mailbody);
  
  $email['mailbody'] = $mailbody;
  
  // Run email through HTML Tidy.
  $email = tidyEmail($email);
  
  return $email;
}

function tidyEmail($email) {
  $mailbody = $email['mailbody'];
  
  // Run body through HTML Tidy if body is html. Tidy destroys new-lines on
  // plain-text emails.
  if ($email['isHTML']) {
    $options = array(
      "wrap" => 0,
      "wrap-php" => FALSE,
      "show-body-only" => TRUE,
      "break" => FALSE,
      "force-output" => TRUE,
      "doctype" => "omit",
      "output-encoding" => "utf8",
      "input-encoding" => "utf8",
    );
    dd_log("Before tidy:");
    dd_log($mailbody);
    $tidy = tidy_parse_string($mailbody, $options); 
    tidy_clean_repair($tidy); 
    $email['mailbody'] = str_replace("\n", "", $tidy);
    $email['mailbody'] = str_replace("\r\n", "", $email['mailbody']);
    dd_log("After tidy:");
    dd_log($email['mailbody']);
  }
  
  return $email;
}

/** Build messageid embedding the parameters so we can read it on response */
function mailnode_build_messageid($params) {
  # add any missing parameters
  $params += Array(
    'nid' => 0,
  );
  $elements = array($params['nid']);
# commented this out because we don't need to be that secure (we're already allowing discussion to be posted!)
#  # Add signature
#  $elements[] = mailnode_signature($elements);
  # combine into an id and return
  return implode('.', $elements) . '@' . variable_get('mailnode_server_string', 'example.com');
}

/*
 * Implement hook_mail_alter mail messages to add comment history
 */
function mailnode_mail_alter(&$message) {
  if ($message['id'] == 'messaging_message-notifications') {  
    $body_text = $message['body'];
    
    // Extract cid.
    preg_match("/%%cid=([0-9]{1,})/", $body_text, $matches);
    $cid = $matches[1];
 
    // Extract nid.
    preg_match("/[0-9]{1,}nid=([0-9]{1,})/", $body_text, $matches);
    $nid = $matches[1];
  
    if (!empty($nid) && !empty($cid)) {
      $comment_history = mailnode_generate_comment_history($nid, $cid);
      $message['body'] = preg_replace("/%%cid=[0-9]{1,}nid=[0-9]{1,}%%/", $comment_history, $body_text);  
    }
  }
}


/*
 * Generate comment history to include in emails
 */
function mailnode_generate_comment_history($nid, $cid) {
  if (empty($nid) || empty($cid)) {
    return "";
  }
  
  $cache = cache_get('mailnode_' . $cid);
  if (!empty($cache->data)) {
    return ($cache->data);
  }
  // If the comment_history is not in cache, generate it fresh.
  else {
    // Grab needed comment data.
    $result = db_query("SELECT cid, uid, comment, timestamp
                       FROM {comments}
                       WHERE nid = %d AND cid < %d
                       ORDER BY timestamp DESC LIMIT 24", $nid, $cid);
    
    $comments = array();
    while ($data = db_fetch_array($result)) {
      $comments[] = $data;
    }
    
    // Fetch information for the original node.
    $node = db_fetch_array(db_query("SELECT n.uid, r.body as comment, r.timestamp
                              FROM node_revisions r JOIN node n on n.nid = r.nid
                              WHERE r.nid = %d
                              ORDER BY r.vid DESC LIMIT 1", $nid));
    
    $comments[] = $node;
    
    // Grab the realname from the database. TODO Make this more generic somehow.
    // Use the real_name module?
    foreach ($comments as &$comment) {
      $comment['realname'] = db_result(db_query("SELECT u.field_name_value
        FROM content_type_uprofile u JOIN node n ON n.nid = u.nid
        WHERE n.uid = %d", $comment['uid']));
    }
    // Create an URL. We'll add comment specific parts to it later on.
    $url = check_url(url('node/' . $nid, array('absolute' => TRUE)));
    $com = $comments[0];
    $depth = 0;
    $mark = "";
    $out = array();
    
    foreach ($comments as $com) {
      $heshewrote = $mark . "On " . format_date($com['timestamp']) . ", " . $com['realname'] .
              " <" . $url;
              
      // Don't add the comment bit to the URL for the node body.
      if ($com['cid']) {
        $heshewrote .= "#comment-" . $com['cid'] . "> wrote:";
      }
      else {
        $heshewrote .= "> wrote:";
      }
      $out[] = $heshewrote;
      $mark = trim($mark) . "> ";
      
      $body = $com['comment'];
      $body = wordwrap($body, 77 - $depth);
      // TODO 4 is the num. for the Messaging Text filter -- need to figure
      // how to pull out the default for messaging and use that.
      $body = messaging_text_render($body, '', 4);
      $body = explode("\n", $body);

      foreach ($body as $line) {
        $out[] = $mark . " " . $line;
      }
      
      $out[] = $mark;
      $depth ++;
    }
    
    array_pop($out);
  }
  $comment_history = implode("\n", $out);
  cache_set('mailnode_' . $cid, $comment_history);
  
  return $comment_history;
}

/*
 * Implementation of hook_nodeapi().
 */
function mailnode_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  //dd_log($op);
  if ($op == "insert" && $node->status) {
    mailnode_send_node_email($node);
  }
}

function mailnode_comment($comment, $op) {
  // $comment can be an object or an array.
  $comment = (object)$comment;

  if ($op == 'publish') {
    // Check that the node is published.
    $node = node_load($comment->nid);    
    if ($node->status) {
      mailnode_send_comment_email($comment, $node);
      
      // User might not be subscribed to thread. Subscribe them now.
      mailnode_save_thread_subscriptions($comment->nid, array($comment->uid));
    }
  }
}

/**
 * Implementation of hook_og().
 *
 * Add a mailnode subscription when a user joins a group
 * and delete should they leave.
 */
function mailnode_og($op, $gid, $uid, $args) {
  switch ($op) {
    case 'user insert':
      mailnode_save_group_subscriptions($gid, 'og', array($uid));
      break;
    
    case 'user delete':
      mailnode_delete_group_subscriptions($gid, 'og', array($uid));
      break;
  }
}